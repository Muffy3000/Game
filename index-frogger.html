<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Frogger Game</title>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #333;
            font-family: Arial, sans-serif;
        }

        .game-container {
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }

        .game-info {
            width: 150px;
            color: white;
            font-size: 24px;
            font-weight: bold;
            padding: 20px;
            background: #FF69B4;
            border-radius: 10px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
        }

        .game-info div {
            margin: 10px 0;
            text-align: center;
        }

        #gameCanvas {
            background-color: #000;
            border: 2px solid #666;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas"></canvas>
        <div class="game-info">
            <div>Score:<br><span id="score">0</span></div>
            <div>Lives:<br><span id="lives">3</span></div>
        </div>
    </div>

    <script>
        // Create collision sound (shorter, more reliable format)
        const collisionSound = new Audio('data:audio/mpeg;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4Ljc2LjEwMAAAAAAAAAAAAAAA//tQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASW5mbwAAAA8AAAASAAAeMwAUFBQUFCIiIiIiIjAwMDAwPz8/Pz8/TU1NTU1NW1tbW1tbaGhoaGhoaHd3d3d3d4aGhoaGhpSUlJSUlKMjIyMjIyMwMDAwMDA/Pz8/Pz9NTU1NTU1bW1tbW1toaGhoaGh3d3d3d3eGhoaGhoaUlJSUlJSjAAAAAAAA//tQxAADwAABpAAAACAAADSAAAAETEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7UMQUg8AAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//tQxCmD1AACpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7UMQ8g9AAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVU=');
        collisionSound.volume = 0.3;

        // Player class
        class Player {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.width = 30;
                this.height = 30;
                this.isAnimatingDeath = false;
                this.deathAnimationFrame = 0;
                this.reset();
            }

            reset() {
                this.x = (this.canvas.width - this.width) / 2;
                this.y = this.canvas.height - this.height - 10;
                this.lives = 3;
                this.isAnimatingDeath = false;
            }

            move(direction) {
                if (this.isAnimatingDeath) return;
                const STEP = 40;
                switch(direction) {
                    case 'up':
                        if (this.y - STEP >= 0) this.y -= STEP;
                        break;
                    case 'down':
                        if (this.y + STEP + this.height <= this.canvas.height) this.y += STEP;
                        break;
                    case 'left':
                        if (this.x - STEP >= 0) this.x -= STEP;
                        break;
                    case 'right':
                        if (this.x + STEP + this.width <= this.canvas.width) this.x += STEP;
                        break;
                }
            }

            loseLife() {
                if (this.isAnimatingDeath) return false;
                
                this.lives--;
                document.getElementById('lives').textContent = this.lives;
                
                try {
                    collisionSound.currentTime = 0;
                    collisionSound.play().catch(e => console.log('Audio play failed:', e));
                } catch (e) {
                    console.log('Audio error:', e);
                }
                
                this.isAnimatingDeath = true;
                this.deathAnimationFrame = 0;
                
                if (this.lives > 0) {
                    setTimeout(() => {
                        this.x = (this.canvas.width - this.width) / 2;
                        this.y = this.canvas.height - this.height - 10;
                        this.isAnimatingDeath = false;
                    }, 1000);
                }
                
                return this.lives <= 0;
            }

            draw() {
                if (this.isAnimatingDeath) {
                    // Flash red and white for death animation
                    const color = this.deathAnimationFrame % 2 === 0 ? '#FF0000' : '#FFFFFF';
                    this.ctx.fillStyle = color;
                    this.ctx.fillRect(this.x - 5, this.y - 5, this.width + 10, this.height + 10);
                    this.deathAnimationFrame++;
                    
                    if (this.deathAnimationFrame >= 10) {
                        this.deathAnimationFrame = 0;
                    }
                } else {
                    this.ctx.fillStyle = '#0F0';
                    this.ctx.fillRect(this.x, this.y, this.width, this.height);
                }
            }
        }

        // Obstacle class
        class Obstacle {
            constructor(canvas, y, speed, width, direction, color) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.width = width;
                this.height = 30;
                this.y = y;
                this.speed = speed;
                this.direction = direction;
                this.color = color;
                this.x = direction === 1 ? -this.width : canvas.width;
            }

            update() {
                this.x += this.speed * this.direction;
                if (this.direction === 1 && this.x > this.canvas.width) {
                    this.x = -this.width;
                } else if (this.direction === -1 && this.x + this.width < 0) {
                    this.x = this.canvas.width;
                }
            }

            draw() {
                this.ctx.fillStyle = this.color;
                this.ctx.fillRect(this.x, this.y, this.width, this.height);
            }

            collidesWith(player) {
                return (
                    this.x < player.x + player.width &&
                    this.x + this.width > player.x &&
                    this.y < player.y + player.height &&
                    this.y + this.height > player.y
                );
            }
        }

        // Game class
        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.canvas.width = 600;
                this.canvas.height = 600;
                this.player = new Player(this.canvas);
                this.obstacles = [];
                this.score = 0;
                this.gameOver = false;
                this.initObstacles();
                this.setupControls();
                this.gameLoop();
            }

            initObstacles() {
                const lanes = [
                    { y: 100, speed: 2, width: 60, direction: 1, color: '#FF0000' },    // Red
                    { y: 200, speed: 3, width: 80, direction: -1, color: '#FFA500' },   // Orange
                    { y: 300, speed: 4, width: 50, direction: 1, color: '#FFFF00' },    // Yellow
                    { y: 400, speed: 2.5, width: 70, direction: -1, color: '#00FF00' }  // Green
                ];

                lanes.forEach(lane => {
                    for (let i = 0; i < 3; i++) {
                        this.obstacles.push(
                            new Obstacle(
                                this.canvas,
                                lane.y,
                                lane.speed,
                                lane.width,
                                lane.direction,
                                lane.color
                            )
                        );
                    }
                });
            }

            setupControls() {
                document.addEventListener('keydown', (e) => {
                    if (this.gameOver) {
                        if (e.key === 'Enter') {
                            this.resetGame();
                        }
                        return;
                    }

                    switch(e.key) {
                        case 'ArrowUp':
                            this.player.move('up');
                            break;
                        case 'ArrowDown':
                            this.player.move('down');
                            break;
                        case 'ArrowLeft':
                            this.player.move('left');
                            break;
                        case 'ArrowRight':
                            this.player.move('right');
                            break;
                    }

                    if (this.player.y <= 50) {
                        this.score++;
                        document.getElementById('score').textContent = this.score;
                        this.player.y = this.canvas.height - this.player.height - 10;
                    }
                });
            }

            checkCollisions() {
                if (this.player.isAnimatingDeath) return;
                
                for (let obstacle of this.obstacles) {
                    if (obstacle.collidesWith(this.player)) {
                        if (this.player.loseLife()) {
                            this.gameOver = true;
                        }
                        break;
                    }
                }
            }

            resetGame() {
                this.player.reset();
                this.score = 0;
                document.getElementById('score').textContent = this.score;
                document.getElementById('lives').textContent = this.player.lives;
                this.gameOver = false;
            }

            update() {
                if (!this.gameOver) {
                    this.obstacles.forEach(obstacle => obstacle.update());
                    this.checkCollisions();
                }
            }

            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw safe zones
                this.ctx.fillStyle = '#0A0';
                this.ctx.fillRect(0, 0, this.canvas.width, 50);
                this.ctx.fillRect(0, this.canvas.height - 50, this.canvas.width, 50);

                this.obstacles.forEach(obstacle => obstacle.draw());
                this.player.draw();

                if (this.gameOver) {
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    
                    this.ctx.fillStyle = 'white';
                    this.ctx.font = '48px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('Game Over!', this.canvas.width / 2, this.canvas.height / 2);
                    this.ctx.font = '24px Arial';
                    this.ctx.fillText('Press Enter to restart', this.canvas.width / 2, this.canvas.height / 2 + 40);
                }
            }

            gameLoop() {
                this.update();
                this.draw();
                requestAnimationFrame(() => this.gameLoop());
            }
        }

        window.onload = () => {
            new Game();
        };
    </script>
</body>
</html>
